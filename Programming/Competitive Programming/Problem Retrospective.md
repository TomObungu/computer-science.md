Current Metacognition:
1. Focus on these topics
	- brute force
	- math
	- constructive algorithms
	- implementation
	- combinatorics
	- number theory
2. Up solve questions from the TLE CP-31 sheet
3. Adopt sublime text editor
4. Increase typing ==accuracy.==
5. Read and take notes of competitive programmers cookbook
6.

| Problem | Status    | Metacognition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | Takeaways                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| ------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2001 B  | Partially | 18:21 Make same with <br>equal number of ops start from left to right<br>18:28 Can only write in the order of  minimum positive integer <br>18:32 can write the forwards and backwards and will always have same number of times. could write forwards and backwards but one array always need one more to be the same<br>18:41 Is it only valid for arrays in which n is odd? - Algorithm is move point to middle then back then? <br>18:54 I think only odd and I think the array is always start at middle then increment and loop back round<br>19:27 I was correct about it only being true for odd numbers but my algorithm to output the numbers is wrong<br>19:28 give up lool<br>                          | Ok so the way to print out the array is this:<br><pre><code><br>            iota(vec.begin(), vec.end(), 1);<br><br>            for(int i = 1; i < n; i += 2)<br><br>                swap(vec[i], vec[i + 1]);<br></code><pre><br><br>This code also forms an array of 1,2,3...n starting from 1. Requires <numeric> header abd <algorithm> header<br><br><br>Plus this this is pretty handy for printing out spaces and then a newline at the end of the vector<br><pre><code><br> for(int i = 0; i < n; i++)<br>        cout << p[i] << " \n"[i + 1 == n];<br></pre></code><br><br>How it works is by checking if it at last part of string then printing \ which is a space then \n which is a new line at end of string.<br> |
| 1974 B  | Yes       | 19:57<br>\|   \|   \|<br>\|---\|---\|<br>\|1\|A\|<br>\|2\|B\|<br>\|3\|C\|<br>\|4\|D\|<br>\|5\|E\|<br>\|6\|F\|<br>\|7\|G\|<br>\|8\|H\|<br>\|9\|I\|<br>\|10\|J\|<br>\|11\|K\|<br>\|12\|L\|<br>\|13\|M\|<br>\|14\|N\|<br>\|15\|O\|<br>\|16\|P\|<br>\|17\|Q\|<br>\|18\|R\|<br>\|19\|S\|<br>\|20\|T\|<br>\|21\|U\|<br>\|22\|V\|<br>\|23\|W\|<br>\|24\|X\|<br>\|25\|Y\|<br>\|26\|Z\|<br>20:10 Began to realize that it uses the distinct set to form a key by replacing the letters. Use that key to decipher original string.<br>20:11 Form the distinct set first then switch swap their symetrical indices to form key then decode.<br>21:14 Finished code and learnt new stuff, handle to wrangle with implementation | Some cool things about sets and iterators: Here's how to modify the end bound of an iterator: <br><br><pre><code><br>        set<char> distinctLetters(b.begin(),b.end());<br><br>  <br><br>        size_t offset = (distinctLetters.size() + 1) / 2;<br><br>  <br><br>        auto ceil_middle_it = distinctLetters.begin();<br><br>        advance(ceil_middle_it, offset);<br><br>        for(auto it = distinctLetters.begin(); it!=ceil_middle_it; it++)<br></code></pre><br><br>How to form a vector from a set<br><br><pre><code><br>       set<char> distinct_lets_set(b.begin(), b.end());<br><br>        vector<char> distinct_lets_vec(distinct_lets_set.begin(), distinct_lets_set.end());<br></pre></code><br><br>  |
| 1849 A  | Yes       | 21:33 always b -2 to start off. Then it is b-- and c-- or b-- or c--<br>21:34 It's c+h - b<br>21:35 its better to do b - 1 to avoid negative vakues<br>21:36 b - 1 then do b--, c+h--, then stop when b == 0 or c+h == 0;<br>21:46 Accepted                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Do not do this again <br>`int b,c,h, layers = 1, sumOfCH = c+h;`<br>Will result in garbage values and screw up everything                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| 2049 A  | No        | 21:16 if 0 count = 1 but its not at the begining of the array<br>21:55<br>Basically if there is all 0s then return 0. If there are no 0s then return 0<br>21:58 If there are more than 1 0s return 2. IF there there is 1 0 return 1<br>22:05 use count_if<br>22:35 gave up because got to sleep - pasted solution in                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 1823 A  | Partially | 17:24 Understood the questions<br>17:37 realised what I could do for case k = 0.<br>17:56 realised that if n == k but k is n is odd then false<br>18:27 Realised that A max is (n+((n-3)^1+1))/2<br>18:33 Feels like the numbers of 1s in the array determine the value of a. Can be used to determine the acceptble values of A. If there is an acceptble value of A then return the array with the corresponding 1s<br>18:53 figured out that it is only YES if the number of ones is equal to (i+((i-3)^2)/2)                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 2035    | N()       | 05:10 Began visualizing the out for each input with a distinct feature. E.g. when n=2,n=4,n=5,7<br>and the erroneous cases e.g. n=3<br>05:20 <br>Deduced a pattern for each corresponding input. realized that n += z, where z alternates between 1 and 2<br>05:23 <br>Tried to spend time to deduce an elegant may to write out the pattern. However refused as I didn't want to take up too much time.<br>05:30 Practically figured it out all out on paper<br>05:45 Desperately getting caught up trying to implement solution<br>05:55 Running into exit code -3 (Runtime error)<br>06:00<br>Temporarily gave up on implementation<br>21:29 Realised my solution was wrong for all cases n > 7                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| 1760 B  | Yes       | 20:30 Pretty trivial question was able to figure it out in first few minutes then implement a solution shortly after<br>20:47 Accepted                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |


